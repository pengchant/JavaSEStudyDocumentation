# 1. 集合

## 1.1 什么是集合

　　集合是存储对象的容器。集合中可以存储任意类型的变量。Java提供了多种集合类，不同集合类的数据结构不同，分别适合在不同的场景使用。

## 1.2 集合和数组

　　数组也用来存储数据，如果定义一个对象数组，例如Object[] objArr；那么对象数组也能存储对象。但是集合和数组有很大区别：

　　（1）数组长度是固定的，集合的长度是可变的。如果无法预先知道需要多少存储多少个数据，那么很难使用数组。

　　（2）数组一般只能存储同一类型的元素，集合可存储不同类型的元素。

　　（3）集合只能存储引用类型的元素。JDK 5实现了自动装箱功能，所以集合形式上也能存储基本数据类型的元素。

## 1.3 Collection接口

　　集合有很多共性，因此集合抽象出了一个Collection接口，下面讲的单例集合都是Collection接口的实现类。下面通过一个实现类来讲Collection接口中的常用方法。

# 2. Collection接口

　　为了了解Collection接口中方法，首先要创建一个集合对象，那么需要用多态方式来创建一个Collection接口的实现类对象。

　　先找到一个实现Collection接口的类。查看API，有如下说明：

　　“JDK 不提供此接口的任何直接实现：它提供更具体的子接口（如 Set 和 List）的实现。”

　　也就是说Collection没有直接的实现类，我们可以找Collection子接口Set或者List接口的实现类。其中，ArrayList是List接口的一个实现类，我们就用它来创建集合对象，以此介绍Collection接口中的方法。【提示，目前看API时会遇到<E>、<T>等字样，而且在IDE中会有警告，这涉及到泛型，暂时不用管它】

## 2.1 添加和删除对象方法

　　（1）public boolean add(Object o)：添加一个元素到集合中。此方法总是返回true，因此返回值不重要。

　　（2）public boolean addAll(Collection c)：将一个集合的元素全部添加到该集合中。

　　（3）public boolean remove(Object o)：将元素从集合中删除（如果有重复，只会删除一个）。如果集合中没有该元素，则返回false（不会出现异常）。

　　（4）public boolean removeAll(Collection c)：移除集合中存在于集合c中的元素，包括重复的元素。只要有一个元素被移除了就返回true。

　　（5）public void clear()：移除集合中所有的元素，集合变为一个空集合。

## 2.2 其他方法

　　（1）public boolean contains(Object o)：判断集合中是否包含指定的元素。对于引用类型，contains方法中是调用对象的equals方法来判断的，因此当集合存储自定义对象时，注意重写好自定义类的equals方法。

　　（2）public boolean isEmpty()：判断集合是否为空。

　　（3）public int size()：返回集合中元素个数。

　　（4）public boolean containsAll(Collection c)：判断集合中是否包含了集合c的所有元素。必须全部包含才返回true。

　　（5）public boolean retainAll(Collection c)：将该集合与集合c进行交集，结果保存在本集合中，如果本集合改变了就返回true，否则返回false。

　　（6）public Object toArray()：将集合转成Object数组。学了泛型，这个方法更好用。

　　（7）public String toString()：Collection重写了toString()方法，可以直接将集合以类似数组的方式输出。

　　下面是将自定义对象存储再集合中的例子。

　　（1）Student类

```java
package com.zhang.test;

public class Student {
    private String name;
    private int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
    // 构造方法
    public Student(){}
    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
    // 下面重写equals、hashCode和toString方法

    public boolean equals(Object obj) {
        if(!(obj instanceof Student)) {
            return false;
        }
        if(obj == this) {
            return true;
        }
        Student stu = (Student) obj;
        if(stu.getName().equals(this.getName()) && stu.getAge() == this.getAge()) {
            // 若姓名和年龄相同，就假定他们是同一对象
            return true;
        } else {
            return false;
        }
    }

    public int hashCode() {
        return this.getName().hashCode() + this.getAge();
    }

    public String toString() {
        return this.getName() + ":" + this.getAge();
    }
}
```

　　（2）主类

```java
package com.zhang.test;

import java.util.ArrayList;
import java.util.Collection;

public class Demo {
    public static void main(String[] args) {
        Collection c = new ArrayList();
        c.add(new Student("张三", 12));
        c.add(new Student("李四", 13));
        c.add(5); //可以加任意类型
        // 判断，底层调用的是equals方法
        System.out.println(c.contains(new Student("张三", 12)));
        // 得到元素个数
        System.out.println(c.size());
        // 输出集合，调用的是toString()方法，显示很友好，把其中自定义对象equals方法也调用了
        System.out.println(c);
    }
}
```

## 2.3 Iterator迭代器

　　迭代器用于对集合元素的遍历。迭代器以内部类的形式存在于集合类中，通过迭代器能够拿到集合中元素，也能通过迭代器来操作元素。

　　调用集合的iterator()方法能得到此集合的迭代器。Collection接口继承自Iterable接口，正是Iterable接口定义了iterator()方法。iterator()方法返回的是Iterator接口，该接口有如下方法以便遍历和获取元素：

　　（1）boolean hasNext()：判断是否还有可迭代的元素。

　　（2）Object next()：获取下一个元素，同时指针再向后移动。如果没有下一个元素，则抛出NoSuchElementException异常。

　　小知识点：如果一个方法能返回任意类型或者接受任意类型，那么返回值类型或者参数类型就可设置为Object，因为Object是所有类的基类。

　　因此常用上面的方法实现遍历，例子：（Student类还是上面的代码）

```java
package com.zhang.test;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

public class Demo {
    public static void main(String[] args) {
        Collection c = new ArrayList();
        c.add(new Student("张三", 12));
        c.add(new Student("李四", 13));
        // 迭代
        Iterator it = c.iterator();
        while(it.hasNext()) {
            // 先拿出对象。由于存储的都是Student，直接转换
            Student stu = (Student) it.next();
            System.out.println(stu);
            /*
            注意，不能这样写：
            System.out.println( ((Student) it.next()).getName() );
            System.out.println( ((Student) it.next()).getAge() );
            这样每次循环都会执行两次next()，会导致跳过元素和出现
            NoSuchElementException的异常
             */
        }
    }
}
```

　　推荐在for循环中创建迭代器并迭代，这样可以尽早释放迭代器资源。代码如下：

```java
package com.zhang.test;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

public class Demo {
    public static void main(String[] args) {
        Collection c = new ArrayList();
        c.add(new Student("张三", 12));
        c.add(new Student("李四", 13));
        // 迭代
        for(Iterator it = c.iterator(); it.hasNext(); ) {
            Student stu = (Student) it.next();
            System.out.println(stu.getName());
            System.out.println(stu.getAge());
        }
    }
}
```

　　迭代器中还有remove()方法，可在遍历时删除元素，但是使用remove()方法之前必须先调用next()方法，否则会出现IllegalStateException异常。此外，在用迭代器迭代过程中，只能通过迭代器操作元素，不能使用集合本身提供的方法或者其他方法操作集合元素，否则会有安全隐患，会抛出并发修改异常ConcurrentModificationException。这点在List集合中还会强调和加深。

　　总结：上述讲的Collection方法和迭代器，在下面讲的单例集合（List和Set集合）中都能使用，因为单例集合就是Collection的实现类。
